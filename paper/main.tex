\documentclass{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage[document]{ragged2e}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}


\begin{document}

\title{Ambiguously-Typed Lambda Calculus}

\author{Athan Clark}

\date{}

\maketitle

\begin{abstract}
\begin{flushleft}
Here, we present the ambiguously-typed lambda calculus - a size-dependent type
system measuring the \textit{shape} of terms, based on their context, and an
additional \textit{substitution system}, facilitating the merge and sort of
multiple terms' parameters.
\end{flushleft}
\end{abstract}

% \cite{Author2year2}

%-------------------------------------------------%
\section{Motivation}
%-------------------------------------------------%

The Simply-Typed Lambda Calculus follows from the untyped lambda calculus in that
there is structural assignment to parameters, and each "step" of arity is
mechanically separated with $\rightarrow$. Values are given type labels, and
arguments' types are checked one-for-one to the specification signature. Higher
order function application, the true nature of lambda calculus, is retained
through parameter specification (or type signature) nesting. The grammars are
structured as follows:

\center{
\begin{multicols}{2}
\begin{minipage}{\columnwidth}
\center{
\underline{Untyped Lambda Calculus}
\vspace{11mm}
\begin{align*}
e = \hspace{2mm} & x\\
                 & \lambda x.e\\
                 & e \hspace{2mm} e
\end{align*}
}
\end{minipage}
\break
\begin{minipage}{\columnwidth}
\center{
\underline{Simply-Typed Lambda Calculus}
\begin{align*}
\tau ::= \tau \rightarrow \tau | T \textrm{\hspace{2mm} where \hspace{2mm}} T \in B
\end{align*}
\begin{align*}
e = \hspace{2mm} & x : \tau\\
                 & \lambda (x : \tau).e\\
                 & e \hspace{2mm} e\\
                 & c
\end{align*}
}
\end{minipage}
\end{multicols}
}

\begin{flushleft}
$c$ is a "term constant", such that $c$ is an inhabitant of a type $T$ included
in our working set $B$.\\
\break
The untyped lambda calculus gives us a foundation to base all others off of -
it is the minimum embodyment of higher-order function application and abstraction.
But, there is no beginning, and no end; it suffices only to provide action, and
not results. This is what the simply-typed lambda calculus fills - it provides
an encoding of the finite "end" of an expression in it's type, by utilizing
$\rightarrow$ for each step.

The simply-typed lambda calculus makes a critical decision - it gives up
infinite arity for the sake of traction and decidable termination.
We present the ambiguously-typing scheme to give back our
infinite arity, at the cost of detailed knowledge.
\end{flushleft}

%-------------------------------------------------%
\section{Overview}
%-------------------------------------------------%

\begin{flushleft}
Our system encodes arity in the space of variables quantified over natural
numbers, and constrained based on requirements induced by application and
abstraction context. This is a size-dependent type system variant, similar to
Cryptol. Indeed, our "size" of terms is ambiguous - it gives us no insight
to how parameters are resolved. We additionally include a \textit{parameter
resulution system} - a method for unifying substitutions. We later shoe-horn
a pseudo-monoid instance to our system, with the \textit{union} of lambdas as our
monoidal append.

Our type system also has decidable and total type inference; the size-dependent
system initially assumes all terms to be polymorphic in arity, then, depending
on how terms are used, minimum bounds are enforced in our sizes based on natural
number literals.
\end{flushleft}

\subsection{Brief Example}

\begin{align}
x &: \forall a \in \mathbb{N}. \Rightarrow &a\label{ex1:eq1}\\
f &: \forall b \in \mathbb{N}. \Rightarrow &b\label{ex1:eq2}\\
f \, x &: \forall a \in \mathbb{N}, b \in \mathbb{N}.
\{a \geq 1\} \Rightarrow &(a - 1) + b\label{ex1:eq3}\\
\end{align}

\begin{flushleft}
In our first examples \ref{ex1:eq1} and \ref{ex1:eq2}, their sizes are purely
polymorphic \textit{because} there is no context telling us how the expression should
behave. In \ref{ex1:eq3}, we can see some interesting ideas: because $f$ was
applied to $x$, we now have a constraint bound to it's
type variable\footnote{A degenerate consequence of our structureless arity specification
is that a type variable's reference to it's term must be syntactically in-order -
$\forall \, a \, b$ over $x \, y$ will match $x$ with $a$, and $y$ with $b$.}.
Also, because $x$ consumed one parameter in $a$, we must decrement it. Lastly,
we take the left-over parameters in $x$ and $a-1$ and combine them; in our
(commutative) sized interpretation, this is simply addition\footnote{This
neglects the order that the parameters get combined intentionally.}.

Note that I didn't include the type of a lambda. Please be patient; we will find
that a function's size depends on it's body.
\end{flushleft}

\subsection{Grandiose Hand-Wave}

\begin{flushleft}
Here is our grammar:
\end{flushleft}

\begin{align}
e = \hspace{2mm} & x                          & \mathrm{term}\\
                 & \lambda x.e                & \mathrm{abstraction}\\
                 & \lceil e \, e              & \mathrm{inner \, application}\\
                 & e \, \lceil e              & \mathrm{outer \, application}\\[1em]
                 & e \, \diamond \rfloor \, e & \mathrm{append}\\
                 & e \, \lfloor \diamond \, e & \mathrm{contra-append}\\
                 & l                          & \mathrm{literal}
\end{align}

\begin{flushleft}
The first four elements of our grammar are inherited from our tradtional untyped
lambda calculus, with two different application styles to handle how parameters
are combined - we stick with simple precedence in this draft
\footnote{
  We could, in theory, make any coinductive zipper facilitate parameter resolution.
}
, such that
$x \, \lceil y$ will precede $y$'s parameters over $x$'s, and vise-versa for
$\lceil x \, y$.\\

\vspace{2mm}
The last three exist for our free monoid - the normal append takes it's left-most
argument as most precedent, while contra-append is convenient for short-circuiting
with rightward precedence.
Literals are not necessary for the soundness of our system, but they will be for
terminating execution - $l : 0$.
\end{flushleft}

\subsubsection{Operator Type Signatures}

\begin{flushleft}
To give a feel for how the system works, it is important to give a description
of the operators we use:
\end{flushleft}

\begin{align}
\lceil f \, x \, :
  & \forall a b \in \mathbb{N}. \{a \geq 1\} \Rightarrow & (a-1) + b \label{op:eq1}\\
f \, \lceil x \, :
  & \forall a b \in \mathbb{N}. \{a \geq 1\} \Rightarrow & (a-1) + b \label{op:eq2}\\
x \, \diamond \rfloor \, y :
  & \forall a b \in \mathbb{N}. \Rightarrow              & a + b\\
x \, \lfloor \diamond \, y :
  & \forall a b \in \mathbb{N}. \Rightarrow              & a + b
\end{align}

\begin{flushleft}
Our monoid does not apply or reduce our parameter size, while application will.
Notice that the size is commutative in our parameter stacks - even though
the parameter stack in \ref{op:eq1} and \ref{op:eq2} are opposite, their size
is the same.
\end{flushleft}

\subsubsection{Elementary Term Type Signatures}

For verbosity, we show the most simple terms and their types. In
$\lambda\mathrm{text}$, a literal is a Haskell \texttt{String}:

\begin{align}
x \, :
  & \forall a \in \mathbb{N}. \Rightarrow & a\\
\mathrm{\texttt{"foo"}} \, :            & & 0\\
\end{align}

\subsection{Abstraction Type Signature}

\begin{flushleft}
In the simply-typed lambda calculus, we can't find the entire type signature
of a lambda term, based solely on the lambda itself - we can see that the
parameter would prepend a $a \rightarrow \ldots$, but $\ldots$ depends entirely
on the body $e$ of $\lambda p.e$.

Our system here is similar, but a bit simpler:
\end{flushleft}

\begin{align}
p :                  &&& \forall a. \Rightarrow & a\\
e :                  &&& \forall b. \Rightarrow & b\\
\lambda p.e : \, &
  if (p \in ftv(e)) & then \, & \forall a b \in \mathbb{N}. \Rightarrow
    & (b+1) + a\\
              &     & else \, & \forall a b \in \mathbb{N}. \Rightarrow
    & b+1 \label{lam:eq3}
\end{align}

\begin{flushleft}
In this instance, our type variables for \ref{lam:eq3} \textit{lenses} into our
lambda for brevity; our actual implementation will construct our types bottom-up,
so one should not take this voodoo seriously.

However, our type signature is fairly straigt forward - if $p$ occours in $e$,
then it's arity must obviously be included in our lambda (but only once - even
multiple occourances of $p$ in $e$ will still be delegated from $p$'s unique
parameter listing) - if it's not in our function body, then there will be no
delegation. This is how we handle constant functions:
\end{flushleft}

\begin{align}
\lambda c . \lambda \epsilon . c : & \forall a b \in \mathbb{N} \Rightarrow
  & a + 1
\end{align}

\begin{flushleft}
Note that we don't type-variable match against the lambda body
because it's already captured with $a$. Absurd hand wave, I know. This will be
fine going bottom-up with our substitution model.
\end{flushleft}

\section{Substitution Mapping}

\begin{flushleft}
We must have some tractable method for this to be legible and actually useful,
which we attempt to present here. First and foremost is the notion of a
\textit{substitution mapping} - an idea we can use when modeling lambdas and
reduction.

\vspace{2mm}
We are going to sidestep everything we've worked on now to give a different
perspective of how to model lambdas, via substitution.
\end{flushleft}

\subsection{Notation}

\newcommand{\head}[1]{\node[shape = rectangle,
                            minimum width = 2cm] {::= $#1$};\\ }
\newcommand{\tail}[1]{\node[shape = rectangle,
                            minimum width = 2cm,
                            minimum height= 2cm] {$#1$};\\ }
\newcommand{\zero}{\draw (-1,0) -- (2,0);\\}

\begin{tikzpicture}
  \matrix[nodes={draw},
          row sep=0cm,
          column sep=0.5cm] {
  \tikzstyle{every node}=[draw]
  \head{x}
  \head{y}
  \tail{a-1}
  \zero
  };
\end{tikzpicture}

\begin{flushleft}
This diagram can be seen as a manual abstraction in our system - we assign
countable parameters at the top of our stack to names we use in our substitution
body, and hand-over the rest to those bound terms. A substitution mapping has
scope to only the parameters declared, both in the body and fall-over parameters.\\

In a substitution body, we have access to a restricted set of operators - monoidal
append, term application, and literals. Free variables should not exist\footnote{
  This will be unavoidable when we translate expressions to substitution maps.
}, and the operators we use in the body are the plain-jane ones we know and love,
because precedence is already handled in our stack system.
\end{flushleft}

\subsection{Translation}

\begin{flushleft}
We assume that substitution maps are the values referenced by ATLC expressions.
A substitution map must be constructively finite, but referencing the "rest"
(for learning purposes) is done through quantification.\\

Literals are 0-ary substitutions, ATLC monoidal append merges respective parameters
and homomorphically settles natural append in the substitution body. Substitution
application has a similar flavour; we consume our bound variable in the applyee
and literally substitute the applied term's substitution body for the variable.
Abstraction may either bind a free variable (when evaluating our expression),
or induce a shadow on a previous binding\footnote{\textit{Previous}, because we
are going "bottom-up".}.
\end{flushleft}

\bibliographystyle{abbrvnat}
\bibliography{winnower_template}

\appendix

\section{Appendix Heading}

\begin{flushleft}

\end{flushleft}

\end{document}
